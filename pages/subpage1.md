---
title: 불확실성에 대항하기
layout: section
subject: 불확실성에 대항하기
---

<!--
이번 발표 제목이 소프트웨어 파괴의 미학이죠? 좀 독특합니다. 어떤 발표일지 궁금하실텐데요,
제일 먼저 불확실성이라는 것에 대해 다뤄보겠습니다.
불확실성에 대항이라 뭔가 거창하죠?
-->

---
layout: center
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 이런 <accent>고민</accent>을 해본 적 있나요?

<!--
먼저 여러분들께 질문 하나 해보겠습니다.
-->

---
layout: center
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 소프트웨어 개발은 너무 많은 것이 <accent>애매모호</accent>하다

<!--
소프트웨어 개발이란 것이 너무 애매모호하게 느껴지진 않으셨나요?
솔직히 저는 대체 적합한 기술은 무엇인지, 이 기능의 정확한 요구사항은 무엇인지, 엣지 케이스는 무엇인지, 좋은 설계란 무엇인지, 좋은 코드라는 것은 무엇인지 많은 것이 애매모호하다고 느낍니다.

게다가 저마다 생각이 다 다릅니다. 업계마다, 도메인마다, 시대마다 다르고 같은 직장 내에서도 개개인마다 선호하는 기술이 다르기 때문에 생각의 차이가 크기도 합니다. 

이 이야기에 공감하시는 분 있을까요? 손 한 번만 들어봅시다. 나만 그렇게 느끼는게 아니라는걸 알면 안심이 되잖아요?
-->

---
layout: default
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 항상 나를 괴롭히던 고민

* 코딩으로 밥벌이를 한지 벌써 10년이 넘었지만...
  * 어째서 아직도 무언가를 <accent>완성하는 것</accent>이 어렵게 느껴지는가?
  * 아직 지식과 경험이 부족한 것인가?
* 애매모호함 앞에서 겸손해지는 나...

<!--
그래서 저는 항상 고민했습니다. 10년을 넘게 일했지만 아직도 무언갈 완성하는것이 어렵고 두렵습니다. 아직 지식과 경험이 부족한걸까요? 자랑은 아니지만 저는 꽤 열심히 살았다고 자부합니다. 아직 부족한 것이 많겠지만 그래도 많은걸 경험해봤습니다.

항상 애매모호함 앞에서는 겸손해지고 두렵습니다. 애매모호하더라도 이끌어야하는 입장이 된다면 결정을 해야합니다. 시간은 우리를 기다려주지 않으니까요. 경험이 있어서 무엇을 선택해야할지 잘 알더라도 만약이라는 생각 앞에선 두렵습니다.
-->

---
layout: center
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 아주 작은 깨달음
소프트웨어 개발이 정말 어려운 이유는 <danger>많은 것이 불확실</danger>하기 때문

<!--
그러다보니 그냥 자연스럽게 깨달았습니다. 소프트웨어 개발은 많은 것이 불확실하기 때문에 정말 어려운거구나. 우리가 돈받고 일하는 이유는 분명 이곳에 있을 것이다라고 생각했죠.
-->

---
layout: center
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# <danger>무엇</danger>이 소프트웨어 개발을 <danger>불확실</danger>하게 만드는걸까?

<img src="/thinking-face.webp" width="180px" style="position: absolute; right: 40px; bottom: 40px;" />

<!--
대체 무엇이 불확실하게 만드는걸까요? 지피지기 백전백승이라고 이걸 먼저 알아야겠다 싶었습니다.
-->

---
layout: default
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 큰 이유 - 비즈니스라는 괴물

* 아무리 잘 설계해도 비즈니스는 급변한다.
  * 가설은 언제나 틀릴 수 있다.
  * 요구사항이 변경되는 것은 당연하다.
  * 경쟁자는 기다려주지 않는다.
  * 도메인 지식 또한 계속 변한다.
* 따라서 개발자의 예측은 높은 확률로 틀릴 수밖에 없다.
  * 확장에 대한 대응이 무의미해질 수 있다.
  * 아키텍처가 적합하지 않아질 수 있다.
  * 공든 탑이 무너지는 슬픔...
  * 내가 작성한 코드는 순식간에 <danger>기술 부채</danger>가 된다.

<!--
제 경험과 많은 서적, 주변 이야기를 종합해보면 결국 가장 큰 이유는 비즈니스라는 괴물이 존재하기 때문입니다. 우리가 아무리 잘 설계하고 구현하더라도 비즈니스라는 복잡성은 엄청납니다. 비즈니스는 계속해서 변하고 그건 우리를 기다려주지 않습니다.

가설은 언제나 틀릴 수 있고, 그로인해 요구사항은 변경됩니다. 우리가 잘 만들어도 빈틈은 있기 마련이고 경쟁자는 그곳을 집요하게 노립니다. 각각의 차이는 있겠지만 시간이 변하면서 도메인 지식 또한 변합니다.

그렇기 때문에 개발자의 예측은 높은 확률로 틀립니다. 바뀌지 않을거라 생각한 것이 바뀌고, 확장할 거라 생각한 기능은 그대로 지워집니다. 우리는 설계 시점에 공들여서 탑을 쌓지만 변경으로 인해 순식간에 무너지고 치워야하는 기술 부채가 되어버립니다.
-->

---
layout: center
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

<img src="/kano-model.png" width="420" />
<span style="font-size: 12px">카노 모델</span>

<!--
그건 그냥 제품 초기 상황만 그런거 아니야? 라고 생각할 수도 있습니다. 근데 그렇지 않습니다.
화면에 보이는 사분면 다이어그램은 카노 모델입니다. 처음 들어보시는 분들이 많을텐데요,
카노 모델은 제품이 제공하는 기능을 분류하는 모델링 방법입니다.

예를 들어, 대부분의 소프트웨어는 회원가입, 로그인을 제공합니다. 이건 너무 당연한 기능입니다. 없으면 크게 불만족스럽지만 있어도 돈을 주고 써야할 매력적인 기능은 아닙니다.

그럼 매력적인 기능은 그 제품만이 제공하는 기능이겠죠? 우리는 보통 매력적인 기능을 보고 구매합니다. 그래서 제품의 코어 비즈니스 모델을 매력적으로 만들기 위해 끊임없이 가설을 세우고 그에 따라 구현합니다. 그리고 언젠가 매력적이게 된다면 그 기능은 안정화가 됐다고 볼 수 있습니다.

어찌보면 당연한 얘기입니다. 근데 이 카노 모델에서 중요한 것은 시간의 흐름입니다. 카노 모델에선 시간이 흐름에 따라 매력적인 기능은 점차 아래로 내려가 언젠가 당연한 품질이 된다고 말합니다.
웹 사이트가 처음 등장하던 시기에는 온라인으로 상품을 구매하는 것 자체가 매우 매력적이고 신기한 기능이었습니다. 그럼 지금은 어떤가요? 쇼핑몰에 결제가 있는 것은 너무 당연하죠? 정말 잘만들어서 너무 편리한 UX라면 매력적일 수도 있지만 대체로는 당연한 기능으로 바라봅니다. 

결국 비즈니스는 안정되는 것이 너무 어렵습니다. 왜냐하면 시간이 흐르면 기존 기능은 매력이 없어지기에 계속 새롭게 변화해야 하기 때문이죠. 따라서 우여곡절 끝에 매력적인 품질을 가진 기능을 만들어도 이는 영원하지 않습니다. 계속 바꿔야 하는거죠. 그에 따라 개발도 다시해야합니다.
-->

---
layout: center
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 시간이 지나도 비즈니스의 복잡성은 죽지 않는다

당시에 완벽했던 코드도 시간이 지나면 가치가 없어진다

<!--
그래서 결론은 시간이 지나도 비즈니스의 복잡성은 죽지 않는다라고 할 수 있습니다.

따라서 우리가 당시에 완벽하게 코드를 짰더라도 감가상각 된다고 볼 수 있습니다. 시간이 지날수록 우리가 작성한 코드는 가치가 없어집니다.
-->

---
layout: default
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 작은 이유 - 지식과 경험의 부족

* 우리는 왜 리팩터링을 하는가?
  * 코드를 이해하기 힘들어서
  * 성능에 문제가 있어서
  * 확장하기 힘들어서

<!--
이어서 제가 생각하기에 큰 이유에 살짝 꼽사리끼는 아주 작은 이유가 하나 더 있습니다.
그건 바로 지식과 경험의 부족입니다.

리팩터링을 예시로 들어볼게요. 우리는 왜 리팩터링을 할까요?
뻔하죠. 코드를 이해하기 힘들거나 잘못짰거나 설계상의 문제로 확장하기 힘들기 때문입니다.
-->

---
layout: default
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 작은 이유 - 지식과 경험의 부족

* 우리는 왜 리팩터링을 하는가?
  * 코드를 이해하기 힘들어서
  * 성능에 문제가 있어서
  * 확장하기 힘들어서
* 리팩터링은 **지식과 경험에 기반한 기술**
  * 리팩터링을 하기에 <accent>가장 좋은 시기는 어떻게 리팩터링을 해야할 지 정확히 알 때</accent>
  * 적절한 기술을 사용할 수 없다면 올바르게 고치는 것은 불가능
    * 다시 작성해도 다시 리팩터링을 하게 될 수 있다.
* 리팩터링이란 지식과 경험이 부족했기에 해야하는 <danger>개발자 스스로 만들어낸 기술부채</danger>

<!--
저는 리팩터링은 지식과 경험에 기반한 기술이라고 생각합니다.
만약 기술이 부족하다면 만들면서도 언젠가 다시 만들어야할 기술부채를 생산하게 됩니다. 물론 이런 상황을 막기위해 규칙, 프레임워크, 코드리뷰 등을 할 수 있습니다.
그럼에도 불구하고 기술부채는 생길 수 있습니다. 리팩터링은 기술이기 때문에 리팩토링을 하기 가장 좋은 시기는 어떻게 리팩토링을 해야할지 정확하게 알 때입니다. 만약 적절한 기술을 선택할 수 없다면 다시 리팩토링 해야하는 코드가 나올 수 있습니다.

그래서 결국 지식과 경험이 부족하면 불확실성이 생길 수 있습니다. 아까 이야기한 큰 이유가 외부 요인으로 인한 불확실성이라면 작은 이유는 내부 요인으로 인한 불확실성입니다. 내부 요인이기 때문에 제어가 가능합니다. 조금 더 공부하고 경험을 쌓으면 해결되는 문제기 때문에 작은 이유라고 했습니다.

물론 이게 너무 심해지면
-->

---
layout: default
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 극복을 위한 노력

* 수학적인 모델링
* 설계 패턴 적용
* 방법론에 대한 공부
* 비즈니스에 대한 이해
* ...

<!--
개발자들은 이를 극복하기 위해 많은 노력을 합니다. 수학적인 방법에서 답을 찾으려 하거나, 설계 패턴을 공부하거나, 방법론을 배우기도 합니다. 그러다보면 결국 비즈니스를 공부하기도 하죠. 공부할게 너무 많아요 안그런가요?
-->

---
layout: center
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

<img src="/silver-bullet.jpeg" width="360px" />

<spacer gap="30" />

## 결국 은총알은 없는가?

<!--
그러다보면 깨닫습니다. 모든 문제를 해결해주는 은총알은 없구나라고.
-->

---
layout: default
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 은총알은 없다

* 모든 것은 Trade-off라는 것을 배우게 된다.
* 따라서 완벽이라는 것은 없다는 것을 깨닫는다.
* 완벽할 수 없다면 확신할 수 없다.
* 우리는 언젠가 <danger>삭제할 수 밖에 없는 코드</danger>를 만들게 된다

<!--
구현을 배우면 더 잘만들기 위한 설계를 배우게 됩니다.
설계를 배우면 결국 트레이드 오프라는 것을 배웁니다.
그래서 유동적으로 해결하기 위해 방법론을 익힙니다.
그렇지만 방법론 또한 만능이 아닙니다. 그렇다고 상황에 맞춰 방법론을 바꾸면 오히려 혼란이 생깁니다.
그래서 완벽이라는 것은 없다는걸 깨닫게되죠. 즉, 확신할 수 없는 상황이 생겨버립니다.
결국 그 끝에는 '우리는 언젠가 삭제할 수 밖에 없는 코드를 만드는구나'라는 생각입니다.
그럼 우리는 어떻게 해야할까요?
-->

---
layout: center
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

<img src="/nietzsche.jpg" width="160px" />
<span style="font-size: 12px">프리드리히 니체</span>

<!--
이 문제에 대해 과거에 위대한 철학자가 방향을 제시해줬습니다. 바로 프리드리히 니체인데요, 다들 이름은 들어봤을거라 생각합니다. 조금 뜬금없죠?

니체는 위대한 철학가지만 예술을 사랑했습니다. 그래서 니체는 첫 작품인 비극에 탄생에서 예술의 방향성에 대해 설명했습니다.
-->

---
layout: default
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 비극의 탄생

* **경계를 파괴하는 힘**
  * 현실, 자연, 무질서, 파괴, 죽음
  * 디오니소스적인 것
* **경계를 인식하고 나누는 힘**
  * 디오니소스적인 힘에 대항하는 이성적인 방법들
  * 분석, 분류, 검증
  * 아폴론적인 것
  * 대부분의 개발자는 매우 아폴론적인 존재

<!--
비극의 탄생에서는 두 힘이 언급됩니다.

첫 번째는 경계를 파괴하는 힘입니다. 현실, 자연, 무질서, 파괴, 죽음과도 같은 것을 말하고 니체는 이를 디오니소스적인 것이라 비유했습니다.

두 번째는 경계를 인식하고 나누는 힘입니다.
니체는 이를 디오니소스적인 힘에 대항하는 이성적인 방법들이라 표현했습니다. 이런 방법은 분석, 분류, 검증 같은 것을 말합니다. 그리고 이를 아폴론적인 것이라 비유했습니다.

분석, 분류, 검증이라 말하면 딱 개발자가 떠오르죠? 우리는 매우 아폴론적인 존재입니다.
-->

---
layout: center
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

<img src="/chaos.png" width="360px" />

<!--
갑자기 이런 이야기를 하다니 조금 뜬금없이 보일 수 있지만, 이 이야기는 매우 소프트웨어 개발과 딱 들어맞습니다. 아마도 소프트웨어 개발도 일종의 창작의 예술이라 그럴지도 모르겠습니다.

그림을 한 번 볼까요?

간운데 스파게티처럼 꼬인 선은 혼돈입니다. 이는 사람일 수도 있고 비즈니스가 다루고자하는 복잡성일 수 있습니다. 비즈니스는 다루고자 하는 혼돈에 경계를 두고 이를 이용해 이익을 얻으려고 합니다. 그 경계에 맞춰 우리는 소프트웨어를 만듭니다. 모델링을 하고 모듈을 만들고 객체간의 협력을 구현합니다.

이대로 완성되면 완벽하겠죠? 하지만 꼬인 스파게티같은 혼돈은 계속 바뀝니다. 비즈니스가 그어놓은 경계를 벗어나며 모양을 마음대로 바꿉니다. 아니면 소프트웨어 설계 당시 분류해놓은 기준을 마구 헤집을 수도 있죠. 그럼 우리는 결국 다시 만들어야 합니다.
-->

---
layout: center
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

<img src="/timeline.png" width="800px" />

<!--
이런걸 느끼는 시간의 순서로 보면 아마 화면과 같을겁니다.
가장 왼쪽이 처음 일하던 시기 오른쪽이 현재라고 보면 
처음엔 열심히 코딩을 배우면서 논리적 사고를 훈련합니다.
그러다보면 한계를 느끼고 패턴과 설계를 공부합니다.
설계도 한계가 있다는 걸 느낍니다. 방법론을 익힙니다.
그럼에도 많은 실패를 겪습니다. 아까전에 이야기했던 것과 똑같죠?
-->

---
layout: center
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 기술만으로는 해결할 수 없는 문제
## 여기서 개발자는 <accent>두 가지 선택</accent>을 할 수 있다

<!--
우리는 이제 깨달았어요 완벽할 수 없다는 것을. 문제는 이 다음입니다.
개발자는 여기서 두 길 중 하나를 선택할 수 있습니다.
-->

---
layout: default
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 염세주의적 태도

* 디오니소스적인 힘에 대항하는 것은 **무의미**하다
  * 어차피 바뀔거야 대충 만들자
  * 설계, 방법론같은 것은 무의미하다
  * 애자일? 제대로 돌아가는 걸 본 적이 없다
* 과연 이것이 옳은 태도일까?
  * 다들 안좋다고 생각하겠지만 실제로는 많은 개발자가 염세주의적 태도를 취한다.
  * <danger>편하고 안락한 길</danger>

<!--
하나는 염세주의로 빠지는 길입니다.
이 길에 빠진 개발자는 어차피 마구잡이로 바뀌는 디오니소스적인 힘에 대항하는 것은 무의미하다고 느낍니다.

그러다보면 이런말들을 하게되죠
어차피 또 바뀔거다 그냥 대충짜라
설계, 방법론은 무의미하다. 그냥 돌아가게 만드는게 최고다.
애자일? 그게 되는 꼬라지를 못봤다.

개인적으로 근거가 없는 말은 아니라고 생각합니다. 근데 과연 이게 옳은 태도일까요?
물어보면 대부분 아니라고 말합니다. 그렇지만 실제로는 많은 개발자가 염세주즤적인 태도를 취합니다.
자기도 모르는 사이에 그렇게 된거죠. 왜냐하면 편하고 안락한 길이기 때문입니다.
-->

---
layout: default
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 맞서 싸우기

* 디오니소스적인 힘을 **받아들이는 것**
  * 완벽할 수 없다는 것을 깨달았다
  * 그럼에도 불구하고 나아가야 한다
* 어떻게 극복해야 하는가?
  * 다음 길을 개척하고 발굴해야 한다
  * <accent>어렵고 견뎌야 하는 길</accent>

<!--
다른 길은 맞써 싸우는 길입니다.

파괴적인 디오니소스적인 힘을 받아들이는 것이죠. 완벽할 수 없다는걸 알았어. 그런데 그게 뭐? 나는 그래도 완벽을 추구하며 더 나은 방법을 찾아볼거야
같은 사고입니다.

그러기 위해서는 끊임없이 더 나은 길을 개척하고 발굴해야합니다. 누군가는 비웃을수도 있습니다. 그래서 이 길은 어렵고 견뎌야하는 길입니다. 딱 니체의 사상 그 자체입니다.
-->

---
layout: default
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 혼돈에 대항한 소프트웨어 업계의 역사

* 추상화 없는 계산의 수행
* 제어 구조의 발명
* 데이터 추상화
* 프로그래밍 패러다임
* MDA
* 재사용 가능한 패턴
* 애자일
* DDD
* 리팩터링 기술
* ...

<!--
생각해보면 소프트웨어 업계는 항상 혼돈에 대항해왔습니다.

처음엔 기술로서 추상화 없는 계산기로 시작했지만, 제어 구조, 데이터 추상화 등이 생겼습니다.

이젠 소프트웨어가 비즈니스를 만났습니다.

그러면서 더 잘만들기 위한 패러다임이 등장했습니다.
설계의 중요성을 이야기하면서 모델 드리븐 아키텍처가 등장했지만, 설계와 구현의 격리는 좋지 않다는 것을 깨닫고 새로운 방법론들이 나왔습니다.
비즈니스와 설계, 구현을 격리하는 탑다운에서 모두가 어우러질 수 있는 애자일이 등장했습니다.

제 생각에는 결국 혼돈에 대항하여 경계를 허물고 더 나은 길을 선택할 수 있는 쪽으로 진화하고 있다고 느낍니다.
-->

---
layout: center
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 이제 어떻게 나아가야 할까?

<!--
그럼 이 다음은 뭐가 될까요? 지금은 알 수 없습니다.
-->

---
layout: default
headerEnable: true
headerTitle: 소프트웨어 파괴의 미학
---

# 제안
* '어차피 지워진다'라는 염세주의적 생각에 빠지기 쉬운 것이 현실
* 그렇다면 거꾸로 생각해서 차라리 잘 지울 수 있게 만들면 어떨까?
* 즉, <danger>파괴</danger>에는 <accent>파괴</accent>로 대응해보자!

<!--
이렇게 마치면 안되겠죠.
저는 그래서 한가지를 제안하겠습니다.
현실을 보면 어차피 지워진다라는 염세주의적 생각에 빠지기 쉽습니다. 우리를 고통스럽게 만들기 때문이죠.
그러면 차라리 거꾸로 생각해서 잘 지울수 있게 만들면 어떨까?라는 생각을 했습니다.

즉, 파괴에는 파괴로 대응하는것이죠.
-->
